grammar ALMAS;


/* 	PARSER */

program : (PROGRAM_BODY)* ;

PROGRAM_BODY : STATEMENTS | FUNCTION ;

ASSIGNMENT : 
	STRING_TYPE IDENTIFIER STRING_ASSIGNMENT |
	DECIMAL_TYPE IDENTIFIER DECIMAL_ASSIGNMENT |
	BOOLEAN_TYPE IDENTIFIER BOOLEAN_ASSIGNMENT ;
	
STRING_ASSIGNMENT: ASSIGNMENT (STRING | FUNCTION_CALL | STRING_CAST);
DECIMAL_ASSIGNMENT: ASSIGNMENT (DECIMAL | FUNCTION_CALL | DECIMAL_CAST) ;
BOOLEAN_ASSIGNMENT: ASSIGNMENT (BOOLEAN | EXPRESSIONS | FUNCTION_CALL | BOOLEAN_CAST) ;

IF :  BARE_IF | BARE_IF ELIF | BARE_IF ELSE ;
BARE_IF: IF_SYMBOL LEFT_P EXPRESSIONS RIGHT_P CURLY_LEFT STATEMENTS CURLY_RIGHT ;
ELIF : BARE_ELIF | BARE_ELIF ELSE;
BARE_ELIF: ELSE_IF_SYMBOL LEFT_P EXPRESSIONS RIGHT_P CURLY_LEFT STATEMENTS CURLY_RIGHT ELIF ;
ELSE : ELSE_SYMBOL CURLY_LEFT STATEMENTS CURLY_RIGHT;

EXPRESSIONS:  EXPRESSION | EXPRESSION BINARY_BOOLEAN_OP EXPRESSIONS;
EXPRESSION:  RELOP_EXPRESSION | UNARY_OP* IDENTIFIER | UNARY_OP* BOOLEAN | UNARY_OP* LEFT_P EXPRESSION RIGHT_P;
RELOP_EXPRESSION:
	(DECIMAL|IDENTIFIER) RELATIONAL_OPERATOR (DECIMAL|IDENTIFIER) 
	| UNARY_OP* LEFT_P RELOP_EXPRESSION RIGHT_P;
	
STATEMENTS: (ASSIGNMENT | IF | LOOP)+ ;
LOOP : FOR_SYMBOL LEFT_P IDENTIFIER COLON DECIMAL? COLON DECIMAL COLON DECIMAL? RIGHT_P CURLY_LEFT LOOP_STATEMENTS CURLY_RIGHT ;
LOOP_STATEMENTS: (STATEMENTS | CONTINUE_SYMBOL | BREAK_SYMBOL)+ ;

WS : ( ' ' | '\t' | '\r' | '\n') -> skip;

PRIMITIVE_TYPE : STRING_TYPE | DECIMAL_TYPE | BOOLEAN_TYPE;

RETURN_TYPE : PRIMITIVE_TYPE | VOID_TYPE;
FUNCTION : FUNCTION_SYMBOL RETURN_TYPE IDENTIFIER LEFT_P FUNC_INPUTS? RIGHT_P CURLY_LEFT STATEMENTS RETURN_ST? CURLY_RIGHT;
		   
FUNCTION_CALL : IDENTIFIER LEFT_P FUNC_ARGS? RIGHT_P;

FUNC_INPUTS : PRIMITIVE_TYPE IDENTIFIER MORE_FUNC_INPUTS? ;
MORE_FUNC_INPUTS : COMMA PRIMITIVE_TYPE IDENTIFIER MORE_FUNC_INPUTS? ;

RETURN_ST : RETURN_SYMBOL (IDENTIFIER|DECIMAL|STRING|BOOLEAN|EXPRESSIONS);

FUNC_ARGS : (IDENTIFIER|DECIMAL|STRING|BOOLEAN|EXPRESSIONS) MORE_FUNC_ARGS? ;

MORE_FUNC_ARGS : COMMA (IDENTIFIER|DECIMAL|STRING|BOOLEAN|EXPRESSIONS) MORE_FUNC_ARGS?;

BOOLEAN_CAST: BOOLEAN_CAST_SYMBOL LEFT_P IDENTIFIER RIGHT_P ; /* can be improved*/
DECIMAL_CAST: DECIMAL_CAST_SYMBOL LEFT_P IDENTIFIER RIGHT_P;
STRING_CAST:  STRING_CAST_SYMBOL LEFT_P IDENTIFIER RIGHT_P;


/*		 LEXER			 */

IDENTIFIER: ('a'..'z'|'A'..'Z') (NUMBER | 'a'..'z' | 'A'..'Z')*;

DECIMAL_TYPE: '#' ;
STRING_TYPE: '$';
BOOLEAN_TYPE: '?';
VOID_TYPE: '_';

ASSIGNMENT_OP: '=';
RELATIONAL_OPERATOR: '>' | '<' | '>=' | '<=';

MUL: '*';
DIV: '/';
ADD: '+';
SUB: '-';
MOD: '%';
INTEGER_DIV: '//';

AND: '&' ;
OR: '|' ;
XOR: '^' ;
NOT: '!' ;

UNARY_OP: NOT;
BINARY_BOOLEAN_OP: AND | OR | XOR; 

EQUAL: 'is';

COMMA: ',';
COLON: ':';
CURLY_RIGHT: '{';
CURLY_LEFT: '}';
LEFT_P: '(';
RIGHT_P: ')';

PRINT_OP: '@print';
INPUT_OP: '@input';

BOOLEAN: 'yes' | 'no';
IF_SYMBOL: 'if';
ELSE_IF_SYMBOL: 'elif';
ELSE_SYMBOL: 'else';

FOR_SYMBOL: 'loop';
FUNCTION_SYMBOL: 'fn';
RETURN_SYMBOL: 'ret';
CONTINUE_SYMBOL: 'go';
BREAK_SYMBOL: 'break';

SIGN : ADD | SUB ;
NUMBER : ('0'..'9')+ ;
DECIMAL : SIGN? NUMBER | SIGN? NUMBER '.' NUMBER | SIGN? '.' NUMBER ;

STRING_LITERAL: '"' ;
STRING: STRING_LITERAL ANYCHAR* STRING_LITERAL;
ANYCHAR: ~('"') ;

BOOLEAN_CAST_SYMBOL: '@?';
STRING_CAST_SYMBOL: '@$';
DECIMAL_CAST_SYMBOL: '@#';
